{"version":3,"file":"useScrollTo-Cc-iHmxJ.js","sources":["../../src/hooks/useScrollTo.ts"],"sourcesContent":["\r\nimport { useCallback } from 'react';\r\n\r\ninterface ScrollOptions {\r\n  offset?: number;\r\n  behavior?: ScrollBehavior;\r\n  attempts?: number;\r\n  delay?: number;\r\n  initialDelay?: number;\r\n}\r\n\r\nexport const useScrollTo = () => {\r\n  const scrollToElement = useCallback((elementId: string, options: ScrollOptions = {}) => {\r\n    const { \r\n      offset = 100,         // Increased default offset for better positioning\r\n      behavior = 'smooth',\r\n      attempts = 20,        // Significantly increased max attempts from 15 to 20\r\n      delay = 350,          // Increased delay between attempts \r\n      initialDelay = 1500   // Significantly increased initial delay for lazy-loaded content\r\n    } = options;\r\n    \r\n    return (e?: React.MouseEvent) => {\r\n      if (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation(); // Stop event bubbling\r\n      }\r\n      \r\n      // Enhanced logging for debugging\r\n      console.log(`üîÑ Attempting to scroll to #${elementId} with initialDelay: ${initialDelay}ms`);\r\n      \r\n      // First try to directly access the element for immediate feedback\r\n      const immediateElement = document.getElementById(elementId) || \r\n                              document.querySelector(`#${elementId}`) || \r\n                              document.querySelector(`[data-section=\"${elementId}\"]`);\r\n      \r\n      if (immediateElement) {\r\n        console.log(`‚úÖ Found element ${elementId} immediately, applying instant pre-scroll...`);\r\n        // Do a quick pre-scroll to give user immediate feedback, will be refined by the complete function\r\n        immediateElement.scrollIntoView({ behavior: 'auto', block: 'start' });\r\n      }\r\n      \r\n      // Try to find the element multiple times with a delay\r\n      // This helps with lazy-loaded components\r\n      let currentAttempt = 0;\r\n      \r\n      const attemptScroll = () => {\r\n        // Enhanced element finding strategies - much more exhaustive\r\n        let element = null;\r\n        \r\n        // Try multiple strategies to find the element\r\n        const selectors = [\r\n          `#${elementId}`, // ID selector\r\n          `[data-section=\"${elementId}\"]`, // Data attribute\r\n          `.${elementId}-section`, // Class based on ID\r\n          `.features-section-loaded`, // Special class for features\r\n          `[role=\"${elementId}\"]`, // ARIA role\r\n          `section[aria-label=\"${elementId.charAt(0).toUpperCase() + elementId.slice(1)} Section\"]`, // ARIA label\r\n          `section.${elementId}` // Section with class\r\n        ];\r\n        \r\n        // Try each selector until we find the element\r\n        for (const selector of selectors) {\r\n          const found = document.querySelector(selector);\r\n          if (found) {\r\n            element = found;\r\n            console.log(`‚úÖ Found element using selector: ${selector}`);\r\n            break;\r\n          }\r\n        }\r\n        \r\n        if (element) {\r\n          console.log(`‚úÖ Found element ${elementId} on attempt ${currentAttempt + 1}, scrolling now...`);\r\n          \r\n          // Multiple scroll methods for redundancy\r\n          try {\r\n            // Method 1: Standard scroll\r\n            const elementPosition = element.getBoundingClientRect().top;\r\n            const offsetPosition = elementPosition + window.pageYOffset - offset;\r\n            \r\n            window.scrollTo({\r\n              top: offsetPosition,\r\n              behavior\r\n            });\r\n            \r\n            // Method 2: Element's scrollIntoView as backup\r\n            setTimeout(() => {\r\n              element?.scrollIntoView({ \r\n                behavior, \r\n                block: 'start'\r\n              });\r\n              \r\n              // Force focus on the element for accessibility\r\n              element.setAttribute('tabindex', '-1');\r\n              element.focus({ preventScroll: true });\r\n            }, 100);\r\n            \r\n            // Dispatch a custom event that the scroll occurred\r\n            document.dispatchEvent(new CustomEvent('scrolledToElement', { \r\n              detail: { id: elementId, success: true } \r\n            }));\r\n            \r\n            // Log success for debugging\r\n            console.log(`üìç Scrolled to ${elementId} at position ${offsetPosition}`);\r\n          } catch (error) {\r\n            console.error(\"Error during scroll:\", error);\r\n            // Final fallback - use window.scrollTo with estimated position\r\n            const roughEstimate = element.getBoundingClientRect().top + window.scrollY - offset;\r\n            window.scrollTo(0, roughEstimate);\r\n          }\r\n        } else {\r\n          console.log(`‚ùå Element ${elementId} not found, attempt ${currentAttempt + 1} of ${attempts}`);\r\n          \r\n          // If we haven't reached the max attempts, try again with a delay\r\n          if (currentAttempt < attempts - 1) {\r\n            currentAttempt++;\r\n            setTimeout(attemptScroll, delay);\r\n          } else {\r\n            console.error(`Failed to find element ${elementId} after ${attempts} attempts`);\r\n            // Dispatch event that scroll failed\r\n            document.dispatchEvent(new CustomEvent('scrollToElementFailed', { \r\n              detail: { id: elementId } \r\n            }));\r\n          }\r\n        }\r\n      };\r\n      \r\n      // Add the initial delay before the first attempt to ensure React has updated the DOM\r\n      // This is crucial for lazy-loaded components\r\n      console.log(`‚è±Ô∏è Waiting ${initialDelay}ms before first attempt...`);\r\n      setTimeout(attemptScroll, initialDelay);\r\n    };\r\n  }, []);\r\n\r\n  return { scrollToElement };\r\n};\r\n"],"names":["useScrollTo","useCallback","elementId","options","offset","behavior","attempts","delay","initialDelay","e","immediateElement","currentAttempt","attemptScroll","element","selectors","selector","found","offsetPosition","error","roughEstimate"],"mappings":"wCAWO,MAAMA,EAAc,KA0HlB,CAAE,gBAzHeC,EAAAA,YAAY,CAACC,EAAmBC,EAAyB,CAAA,IAAO,CACtF,KAAM,CACJ,OAAAC,EAAS,IACT,SAAAC,EAAW,SACX,SAAAC,EAAW,GACX,MAAAC,EAAQ,IACR,aAAAC,EAAe,IAAA,EACbL,EAEJ,OAAQM,GAAyB,CAC3BA,IACFA,EAAE,eAAA,EACFA,EAAE,gBAAA,GAIJ,QAAQ,IAAI,+BAA+BP,CAAS,uBAAuBM,CAAY,IAAI,EAG3F,MAAME,EAAmB,SAAS,eAAeR,CAAS,GAClC,SAAS,cAAc,IAAIA,CAAS,EAAE,GACtC,SAAS,cAAc,kBAAkBA,CAAS,IAAI,EAE1EQ,IACF,QAAQ,IAAI,mBAAmBR,CAAS,8CAA8C,EAEtFQ,EAAiB,eAAe,CAAE,SAAU,OAAQ,MAAO,QAAS,GAKtE,IAAIC,EAAiB,EAErB,MAAMC,EAAgB,IAAM,CAE1B,IAAIC,EAAU,KAGd,MAAMC,EAAY,CAChB,IAAIZ,CAAS,GACb,kBAAkBA,CAAS,KAC3B,IAAIA,CAAS,WACb,2BACA,UAAUA,CAAS,KACnB,uBAAuBA,EAAU,OAAO,CAAC,EAAE,cAAgBA,EAAU,MAAM,CAAC,CAAC,aAC7E,WAAWA,CAAS,EAAA,EAItB,UAAWa,KAAYD,EAAW,CAChC,MAAME,EAAQ,SAAS,cAAcD,CAAQ,EAC7C,GAAIC,EAAO,CACTH,EAAUG,EACV,QAAQ,IAAI,mCAAmCD,CAAQ,EAAE,EACzD,KACF,CACF,CAEA,GAAIF,EAAS,CACX,QAAQ,IAAI,mBAAmBX,CAAS,eAAeS,EAAiB,CAAC,oBAAoB,EAG7F,GAAI,CAGF,MAAMM,EADkBJ,EAAQ,sBAAA,EAAwB,IACf,OAAO,YAAcT,EAE9D,OAAO,SAAS,CACd,IAAKa,EACL,SAAAZ,CAAA,CACD,EAGD,WAAW,IAAM,CACfQ,GAAA,MAAAA,EAAS,eAAe,CACtB,SAAAR,EACA,MAAO,OAAA,GAITQ,EAAQ,aAAa,WAAY,IAAI,EACrCA,EAAQ,MAAM,CAAE,cAAe,EAAA,CAAM,CACvC,EAAG,GAAG,EAGN,SAAS,cAAc,IAAI,YAAY,oBAAqB,CAC1D,OAAQ,CAAE,GAAIX,EAAW,QAAS,EAAA,CAAK,CACxC,CAAC,EAGF,QAAQ,IAAI,kBAAkBA,CAAS,gBAAgBe,CAAc,EAAE,CACzE,OAASC,EAAO,CACd,QAAQ,MAAM,uBAAwBA,CAAK,EAE3C,MAAMC,EAAgBN,EAAQ,sBAAA,EAAwB,IAAM,OAAO,QAAUT,EAC7E,OAAO,SAAS,EAAGe,CAAa,CAClC,CACF,MACE,QAAQ,IAAI,aAAajB,CAAS,uBAAuBS,EAAiB,CAAC,OAAOL,CAAQ,EAAE,EAGxFK,EAAiBL,EAAW,GAC9BK,IACA,WAAWC,EAAeL,CAAK,IAE/B,QAAQ,MAAM,0BAA0BL,CAAS,UAAUI,CAAQ,WAAW,EAE9E,SAAS,cAAc,IAAI,YAAY,wBAAyB,CAC9D,OAAQ,CAAE,GAAIJ,CAAA,CAAU,CACzB,CAAC,EAGR,EAIA,QAAQ,IAAI,cAAcM,CAAY,4BAA4B,EAClE,WAAWI,EAAeJ,CAAY,CACxC,CACF,EAAG,CAAA,CAAE,CAEI"}